# Считываем два числа: n (длина массива) и k (размер окна)
n, k = [int(x) for x in input().split()]

# Считываем массив чисел
mass = [int(x) for x in input().split()]

# Инициализируем два стека:
# stack1 - для хранения элементов, которые добавляются в текущее окно
# stack2 - для хранения элементов, которые перемещаются из stack1 при сдвиге окна
stack1 = []  # Первый стек (вход)
stack2 = []  # Второй стек (выход)

# Инициализируем список для хранения минимальных значений в каждом окне
result_min = []

# Функция для добавления элемента в стек
def push(stack, value):
    # Если стек пуст, добавляем элемент и указываем, что он же является минимальным
    if not stack:
        stack.append((value, value))  # (элемент, минимум)
    # Если стек не пуст, добавляем элемент и обновляем минимум
    else:
        stack.append((value, min(value, stack[-1][1])))

# Функция для извлечения элемента из стека
def pop(stack):
    # Удаляем последний элемент из стека и возвращаем его значение (первый элемент кортежа)
    return stack.pop()[0]

# Функция для получения минимального значения в текущем окне
def print_min():
    # Если оба стека пусты, возвращаем None (этот случай не должен происходить в корректной работе)
    if not stack2 and not stack1:
        return None
    # Если stack1 пуст, возвращаем минимум из stack2
    if not stack1:
        return stack2[-1][1]
    # Если stack2 пуст, возвращаем минимум из stack1
    if not stack2:
        return stack1[-1][1]
    # Если оба стека не пусты, возвращаем минимальное значение из двух стеков
    return min(stack1[-1][1], stack2[-1][1])

# Основной цикл: проходим по каждому элементу массива
for i in range(0, n):
    # Если окно переполнено (содержит k элементов), удаляем элемент из stack2
    if i >= k:
        # Если stack2 пуст, переносим все элементы из stack1 в stack2
        if not stack2:
            while stack1:
                push(stack2, pop(stack1))
        # Удаляем элемент из stack2 (элемент, который выходит из окна)
        pop(stack2)

    # Добавляем текущий элемент в stack1
    push(stack1, mass[i])

    # Если окно сформировано (содержит k элементов), добавляем минимум в результат
    if i >= k - 1:
        result_min.append(print_min())

# Выводим результат: минимальные значения для каждого окна, разделенные пробелами
print(*result_min)