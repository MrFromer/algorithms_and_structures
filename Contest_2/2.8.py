# Считываем количество элементов в массиве
n = int(input())

# Считываем массив чисел, разделенных пробелами, и преобразуем их в список целых чисел
# Заменяем символы новой строки на пробелы, чтобы избежать ошибок при вводе
datas = [int(x) for x in input().replace("\n", " ").split()]

# Создаем массив для хранения префиксных сумм
# Префиксная сумма — это сумма всех элементов массива от начала до текущего индекса
# Размер массива prefix_summ на 1 больше, чтобы упростить вычисления
prefix_summ = [0] * (n + 1)

# Вычисляем префиксные суммы
for i in range(n):
    prefix_summ[i + 1] = prefix_summ[i] + datas[i]

# Создаем массив left для хранения индексов ближайшего меньшего элемента слева
# Изначально заполняем его значениями -1 (если меньшего элемента нет)
left = [-1] * n

# Используем стек для нахождения ближайшего меньшего элемента слева
stack = []
for i in range(n):
    # Удаляем из стека все элементы, которые больше или равны текущему элементу
    while stack and datas[stack[-1]] >= datas[i]:
        stack.pop()
    # Если стек не пуст, то ближайший меньший элемент слева — это последний элемент в стеке
    if stack:
        left[i] = stack[-1]
    else:
        # Иначе меньшего элемента слева нет
        left[i] = -1
    # Добавляем текущий индекс в стек
    stack.append(i)

# Создаем массив right для хранения индексов ближайшего меньшего элемента справа
# Изначально заполняем его значениями n (если меньшего элемента нет)
right = [n] * n

# Используем стек для нахождения ближайшего меньшего элемента справа
stack = []
for i in range(n - 1, -1, -1):  # Идем с конца массива в начало
    # Удаляем из стека все элементы, которые больше или равны текущему элементу
    while stack and datas[stack[-1]] >= datas[i]:
        stack.pop()
    # Если стек не пуст, то ближайший меньший элемент справа — это последний элемент в стеке
    if stack:
        right[i] = stack[-1]
    else:
        # Иначе меньшего элемента справа нет
        right[i] = n
    # Добавляем текущий индекс в стек
    stack.append(i)

# Инициализируем переменную для хранения максимального произведения
max_product = 0

# Перебираем все элементы массива
for i in range(n):
    # Находим границы подотрезка, где datas[i] является минимумом
    # l — левая граница (включительно)
    l = left[i] + 1
    # r — правая граница (не включительно)
    r = right[i]

    # Вычисляем сумму на подотрезке с помощью префиксных сумм
    current_sum = prefix_summ[r] - prefix_summ[l]

    # Вычисляем произведение суммы на минимум (datas[i])
    current_product = current_sum * datas[i]

    # Обновляем максимальное произведение, если текущее больше
    if current_product > max_product:
        max_product = current_product

# Выводим результат
print(max_product)