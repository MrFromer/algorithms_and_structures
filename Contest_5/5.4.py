# Константы для хеширования:
# MOD - большое простое число для модуля (чтобы избежать переполнения)
# BASE - основание системы хеширования (большое случайное число)
MOD = 10**18 + 3
BASE = 911382629

# Читаем входную строку и удаляем пробелы по краям
s = input().strip()
n = len(s)  # Длина строки

# Удваиваем строку, чтобы легко получать циклические сдвиги
# Например, для "abc" получим "abcabc" - тогда сдвиг на i позиций: s[i:i+n]
doubled = s + s

# ==============================================
# ПРЕДВАРИТЕЛЬНОЕ ВЫЧИСЛЕНИЕ ХЕШЕЙ
# ==============================================

# prefix[i] - хеш первых i символов удвоенной строки doubled
prefix = [0] * (2 * n + 1)

# power[i] = BASE^i % MOD - степени базы для быстрого пересчета хешей
power = [1] * (2 * n + 1)

# Заполняем массивы prefix и power
for i in range(2 * n):
    # Вычисляем следующую степень BASE по модулю MOD
    power[i + 1] = (power[i] * BASE) % MOD
    
    # Вычисляем хеш для первых i+1 символов:
    # новый хеш = (старый хеш * BASE + код символа) % MOD
    prefix[i + 1] = (prefix[i] * BASE + ord(doubled[i])) % MOD

# ==============================================
# ФУНКЦИЯ ДЛЯ ПОЛУЧЕНИЯ ХЕША ПОДСТРОКИ
# ==============================================

def get_hash(l, r):
    """
    Возвращает хеш подстроки doubled[l..r-1]
    Формула: hash = (prefix[r] - prefix[l] * power[r-l]) % MOD
    Это позволяет за O(1) получить хеш любой подстроки
    """
    return (prefix[r] - prefix[l] * power[r - l]) % MOD

# ==============================================
# ПОИСК ЛЕКСИКОГРАФИЧЕСКИ МИНИМАЛЬНОГО СДВИГА
# ==============================================

left = 0  # Индекс текущего минимального сдвига (изначально 0-й сдвиг)

# Перебираем все возможные сдвиги (от 1 до n-1)
for right in range(1, n):
    # Бинарный поиск первой позиции, где сдвиги left и right отличаются
    low, high = 0, n
    
    while low < high:
        mid = (low + high) // 2  # Средняя позиция для сравнения
        
        # Получаем хеши подстрок (left..left+mid) и (right..right+mid)
        hash_left = get_hash(left, left + mid + 1)
        hash_right = get_hash(right, right + mid + 1)
        
        if hash_left == hash_right:
            # Если хеши совпадают, ищем различия правее
            low = mid + 1
        else:
            # Если хеши разные, ищем различия левее
            high = mid
    
    # После бинарного поиска low - первая позиция различия
    # Сравниваем символы в этой позиции
    if doubled[right + low] < doubled[left + low]:
        # Если right-сдвиг меньше, делаем его новым минимальным
        left = right

# ==============================================
# ВЫВОД РЕЗУЛЬТАТА
# ==============================================

# Выводим минимальный сдвиг: подстроку длиной n начиная с left
print(doubled[left : left + n])







#Альтернативное решение (через посимвольную проверку строк и нахождения минимальной строки по алфавиту)
# Читаем входную строку и удаляем пробелы по краям
s = input().strip()
# Получаем длину строки
n = len(s)

# ==============================================
# ПОДГОТОВКА ДАННЫХ
# ==============================================

# Удваиваем строку, чтобы легко получать циклические сдвиги
# Например, для "abc" получим "abcabc" - тогда сдвиг на i позиций: s[i:i+n]
doubled = s + s

# ==============================================
# ПОИСК МИНИМАЛЬНОГО СДВИГА
# ==============================================

# min_shift будет хранить индекс начала минимального сдвига
# Изначально считаем, что минимальный сдвиг - это сама строка (сдвиг 0)
min_shift = 0

# Перебираем все возможные сдвиги (от 1 до n-1)
for i in range(1, n):
    # Сравниваем текущий сдвиг (начинается в позиции i)
    # с текущим минимальным (начинается в min_shift)
    
    # Поиск первого несовпадающего символа
    for j in range(n):
        # Сравниваем соответствующие символы двух сдвигов
        if doubled[min_shift + j] != doubled[i + j]:
            # Если нашли различие
            if doubled[i + j] < doubled[min_shift + j]:
                # Если символ в текущем сдвиге меньше,
                # значит этот сдвиг лексикографически меньше
                min_shift = i  # Запоминаем новый минимальный сдвиг
            # Прерываем сравнение, так как уже нашли различие
            break
    
    # Если все символы совпали (break не выполнился),
    # то сдвиги идентичны - ничего не меняем

# ==============================================
# ВЫВОД РЕЗУЛЬТАТА
# ==============================================

# Выводим минимальный сдвиг: подстроку длиной n начиная с min_shift
print(doubled[min_shift:min_shift + n])