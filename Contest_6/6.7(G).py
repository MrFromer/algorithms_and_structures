# Чтение входных данных: количество городов (n) и дорог (m)
n, m = map(int, input().split())
# Определение "бесконечности" для инициализации расстояний
INF = float('inf')

# Инициализация матрицы расстояний размером (n+1)x(n+1)
# Используем n+1 чтобы удобно работать с индексами от 1 до n
dist = [[INF] * (n + 1) for _ in range(n + 1)]

# Заполнение диагонали нулями (расстояние от города до самого себя = 0)
for i in range(1, n + 1):
    dist[i][i] = 0

# Вывод начальной матрицы расстояний для отладки
print("Начальная матрица расстояний:")
print(dist)

# Чтение информации о дорогах и заполнение матрицы расстояний
for _ in range(m):
    # Чтение данных о дороге: город u, город v, длина дороги w
    u, v, w = map(int, input().split())
    # Обновляем расстояние между городами u и v, если нашли более короткую дорогу
    if w < dist[u][v]:
        dist[u][v] = w  # Обновляем расстояние u->v
        dist[v][u] = w  # Дорога двусторонняя, поэтому обновляем и v->u

# Вывод матрицы расстояний после заполнения дорогами
print("Матрица после добавления дорог:")
print(dist)

# Алгоритм Флойда-Уоршелла для нахождения кратчайших путей между всеми парами городов
for k in range(1, n + 1):         # Промежуточный город
    for i in range(1, n + 1):     # Город отправления
        for j in range(1, n + 1): # Город назначения
            # Обновляем расстояние, если путь через город k короче
            dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])

# Поиск оптимального города для проведения семинара:
# Ищем город с минимальным максимальным расстоянием до других городов
min_max_dist = INF  # Изначально устанавливаем "бесконечность"
result_city = -1     # Изначально город не выбран

# Перебираем все города от 1 до n
for city in range(1, n + 1):
    # Находим максимальное расстояние от текущего города до всех остальных
    # dist[city][1:n+1] - это все расстояния от текущего города до других
    current_max = max(dist[city][1: n + 1])
    
    # Если нашли город с меньшим максимальным расстоянием,
    # или такой же максимальное расстояние, но с меньшим номером города
    if current_max < min_max_dist or (current_max == min_max_dist and city < result_city):
        min_max_dist = current_max  # Обновляем минимальное максимальное расстояние
        result_city = city          # Запоминаем текущий город как оптимальный

# Вывод результата - номера оптимального города
print("Оптимальный город для проведения семинара:")
print(result_city)