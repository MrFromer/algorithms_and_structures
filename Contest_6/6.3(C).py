#Тут я решил по итогу другую задачу случайно и по сути нахожу сам топологическую сортировку для графа.
#Т.е я прохожусь DFS (обход в глубину) и заношу пройденную вершину до конца (т.е когда у вершины уже нет не пройденных детей, она тупиковая) в список посещённых и в конце переворачиваю список
#Переворачиваю потому что я записывал самые нижние вершины в начало, а нужно записывать вершины с самых верхних (корней) до самых нижних (листьев)

 
import sys
sys.setrecursionlimit(200000)

n, m = [int(x) for x in input().split()]

spisok_smezh = [[] for _ in range(n+1)]

for _ in range(m):
    a, b = [int(x) for x in input().split()]
    spisok_smezh[a].append(b)
    
topo = [int(x) for x in input().split()]

visited_vertexs = [False]*(n+1)
visited = []

def DFS(v):
    visited_vertexs[v] = True
    for children in spisok_smezh[v]:
        if not visited_vertexs[children]:
            DFS(children)
    visited.append(v)

for v in range(1,n+1):
    if visited_vertexs[v] == False:
        component = []
        DFS(v)
    
visited.reverse()        
print(visited)


#Вот решение самой задачи: 
#Тут я уже прохусь по введённому массиву топологическому и завожу словарь, где у меня ключом является вершина, а значением её номер сверху в низ по ходу прохождения графа 
#И сверяюсь, что номер вершины родителя всегда должен быть меньше номера вершины ребёнка (т.е родитель стоит выше ребёнка по ходу движения от корня к листьям)
import sys  # Импорт модуля для работы с системными функциями (например, выход из программы)

# Считываем количество вершин (n) и рёбер (m) графа
n, m = [int(x) for x in input().split()]

# Создаём список смежности (spisok_smezh) размером n+1 (индексы от 0 до n)
spisok_smezh = [[] for _ in range(n+1)]

# Заполняем список смежности рёбрами графа
for _ in range(m):
    a, b = [int(x) for x in input().split()]  # Считываем ребро a → b
    spisok_smezh[a].append(b)  # Добавляем b в список смежности вершины a
    
# Считываем предполагаемую топологическую сортировку (topo)
topo = [int(x) for x in input().split()]

# Выводим список смежности для отладки
print('Список смежности: ', spisok_smezh)

# Создаём словарь pos, где ключи — вершины, а значения — их позиции в topo
# Например, для topo = [2, 1, 3] получим pos = {2:0, 1:1, 3:2}
pos = {x: i for i, x in enumerate(topo)}  # {вершина: её индекс в topo}

# Выводим словарь pos для отладки
print('POS: ', pos)

# Проверяем, является ли topo корректной топологической сортировкой
for u in range(1, n+1):  # Перебираем все вершины графа
    print('Элемент из pos и его номер: ', u, pos[u])  # Отладочный вывод
    for v in spisok_smezh[u]:  # Перебираем всех соседей вершины u
        print('Элемент из списка смежности у этого элемента и его номер: ', v, pos[v])  # Отладочный вывод
        if pos[u] > pos[v]:  # Если u стоит в topo ПОСЛЕ v — это нарушение топологической сортировки
            print("NO")  # Выводим "NO"
            sys.exit()  # Завершаем программу

# Если все рёбра удовлетворяют условию pos[u] < pos[v], выводим "YES"
print("YES")