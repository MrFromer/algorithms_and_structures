# from collections import deque  # Импортируем deque для эффективной работы с очередью

# def BFS_min_digit(k):
#     """
#     Функция для поиска минимальной суммы цифр числа, делящегося на k.
#     Использует BFS (поиск в ширину) с оптимизацией по остаткам от деления.
    
#     Аргументы:
#         k (int): Число, на которое должно делиться искомое число (2 ≤ k ≤ 10^5)
    
#     Возвращает:
#         int: Минимальная сумма цифр найденного числа
#     """
    
#     # Инициализация очереди для BFS
#     queue = deque()
    
#     # Массив для хранения минимальных сумм цифр для каждого возможного остатка
#     # Изначально все остатки имеют "бесконечную" сумму (еще не найдены)
#     min_sum = [float('inf')] * k

#     # Начальная инициализация: рассматриваем все однозначные числа (1-9)
#     for digit in range(1, 10):
#         # Вычисляем остаток от деления числа на k
#         ostatok = digit % k
        
#         # Если текущая цифра дает меньшую сумму для этого остатка, чем найденная ранее
#         if digit < min_sum[ostatok]:
#             # Обновляем минимальную сумму для этого остатка
#             min_sum[ostatok] = digit
            
#             # Добавляем в очередь пару (остаток, сумма цифр)
#             queue.append((ostatok, digit))

#     # Основной цикл BFS
#     while queue:
#         # Извлекаем первый элемент из очереди
#         ostatok, tek_sum = queue.popleft()
        
#         # Для чисел k < 10 пропускаем специальную обработку (не используется в текущей версии)
#         if k < 10:
#             pass
        
#         # Если остаток равен 0, значит мы нашли число, делящееся на k
#         elif ostatok == 0:
#             # Возвращаем сумму цифр этого числа
#             return tek_sum
        
#         # Генерируем новые числа, добавляя к текущему цифры от 0 до 9
#         for digit in range(0, 10):
#             # Вычисляем новый остаток от деления
#             new_ostatok = (ostatok * 10 + digit) % k
            
#             # Вычисляем новую сумму цифр
#             new_sum = tek_sum + digit
            
#             # Если новая сумма лучше (меньше) ранее найденной для этого остатка
#             if new_sum < min_sum[new_ostatok]:
#                 # Обновляем минимальную сумму для этого остатка
#                 min_sum[new_ostatok] = new_sum
                
#                 # Добавляем новое состояние в очередь для дальнейшего исследования
#                 queue.append((new_ostatok, new_sum))
    
#     # Если не нашли решения в основном цикле (теоретически недостижимо, так как само k делится на k)
#     return min_sum[0]

# # Считываем входные данные
# K = int(input())

# # Вызываем функцию и выводим результат
# print(BFS_min_digit(K))


#Решение через кучи heapq (работает быстрее, т.к кучи всегда выдают наименьший элемент, поэтому мы сразу берём самую оптимальную мин сумму)
from heapq import heappush, heappop

def find_min_digit_sum(K):
    min_sum = [float('inf')] * K
    heap = []
    
    # Инициализация: начинаем с цифр 1-9
    for digit in range(1, 10):
        rem = digit % K
        if digit < min_sum[rem]:
            min_sum[rem] = digit
            heappush(heap, (digit, rem))
    
    while heap:
        s, rem = heappop(heap)
        
        # Ранний выход при нахождении решения
        if rem == 0:
            return s
        
        # Пропускаем устаревшие состояния
        if s > min_sum[rem]:
            continue
        
        # Генерируем новые состояния
        for d in range(0, 10):
            new_rem = (rem * 10 + d) % K
            new_s = s + d
            
            if new_s < min_sum[new_rem]:
                min_sum[new_rem] = new_s
                heappush(heap, (new_s, new_rem))
    
    return min_sum[0]

K = int(input())
print(find_min_digit_sum(K))