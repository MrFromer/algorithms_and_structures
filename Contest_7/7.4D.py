# Считываем размеры доски n (строки) × m (столбцы)
n, m = [int(x) for x in input().split()]

# Инициализация матрицы динамического программирования
# dp[i][j] будет содержать количество способов добраться до клетки (i,j)
dp = [[0] * m for _ in range(n)]
dp[0][0] = 1  # Начальная позиция (0,0) - 1 способ (никуда не ходить)

# Все возможные ходы коня (8 направлений)
moves = [
    (2, 1), (1, 2),    # Вниз-вправо
    (-1, 2), (-2, 1),   # Вверх-вправо
    (-2, -1), (-1, -2), # Вверх-влево
    (1, -2), (2, -1)    # Вниз-влево
]

# Диагональный перебор клеток доски
# s = i + j - сумма индексов, определяющая диагональ
for s in range(1, n + m - 1):
    # Определяем диапазон строк i для текущей диагонали s
    # max(0, s-(m-1)) - нижняя граница (чтобы j не выходил за пределы)
    # min(n, s+1) - верхняя граница (чтобы i не выходил за пределы)
    for i in range(max(0, s - (m - 1)), min(n, s + 1)):
        j = s - i  # Вычисляем столбец j для текущей строки i
        
        # Проверяем все возможные ходы коня
        for di, dj in moves:
            # Координаты предыдущей клетки, откуда мог прийти конь
            pi, pj = i - di, j - dj
            
            # Проверяем, что предыдущая клетка в пределах доски
            if 0 <= pi < n and 0 <= pj < m:
                # Добавляем количество способов из предыдущей клетки
                dp[i][j] += dp[pi][pj]

# Выводим количество способов добраться в правый нижний угол (n-1, m-1)
print(dp[n-1][m-1])