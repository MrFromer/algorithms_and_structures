# Чтение входных данных
n, k = [int(x) for x in input().split()]  # n - общее число столбиков, k - максимальная длина прыжка
coins = [int(x) for x in input().split()]  # монеты на столбиках 2..n-1 (в 1-индексации)

# Инициализация динамики
dp = [0] * n  # dp[i] - максимальная сумма монет на i-м столбике (0-индексация)
prev = [-1] * n  # prev[i] - индекс предыдущего столбика, откуда пришли на i-й

for i in range(1, n):
    start = max(0, i - k)  # начало диапазона предыдущих k столбиков (не меньше 0)
    max_val = -9999999999999999  # "минус бесконечность" для поиска максимума
    best_prev = -1  # индекс лучшего предыдущего столбика
    
    # Перебираем все возможные предыдущие позиции
    for j in range(start, i):
        if dp[j] > max_val:
            max_val = dp[j]
            best_prev = j
    
    # Определяем монеты для текущего столбика
    if 1 <= i <= n - 2:  # монеты есть только на столбиках 2..n-1 (в 1-индексации)
        cur_coin = coins[i - 1]  # coins[0] соответствует 2-му столбику
    else:  # первый (0) и последний (n-1) столбики не дают монет
        cur_coin = 0
    
    dp[i] = cur_coin + max_val  # обновляем dp
    prev[i] = best_prev  # запоминаем, откуда пришли

# Восстановление пути
path = []
current = n - 1  # начинаем с последнего столбика
while current != -1:
    path.append(current + 1)  # переводим в 1-индексацию
    current = prev[current]  # идём назад по цепочке

path.reverse()  # разворачиваем путь (от 1 до n)

# Вывод результатов
print(dp[n-1])  # максимальная сумма монет
print(len(path)-1)  # количество прыжков (число элементов минус 1)
print(*path)  # номера столбиков через пробел