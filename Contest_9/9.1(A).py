import sys

# Читаем все входные данные сразу для ускорения работы
input = sys.stdin.read().split()
ptr = 0  # Указатель на текущую позицию в входных данных

# Читаем размер массива (n) и количество операций (m)
n = int(input[ptr])
m = int(input[ptr+1])
ptr += 2

# Константа для обозначения "бесконечности" (используется как нейтральный элемент для минимума)
INF = float('inf')

# Вычисляем ближайшую степень двойки, не меньшую n, для оптимального размера дерева
size = 1
while size < n:
    size <<= 1  # Эквивалентно умножению на 2

# Инициализируем дерево отрезков и массив для ленивых обновлений
trees = [0] * (2 * size)  # Дерево для хранения минимумов
lazy = [0] * (2 * size)   # Массив для отложенных операций прибавления

def push(v, tl, tr):
    """Функция проталкивания ленивого обновления в детей"""
    if lazy[v] != 0 and tl != tr:  # Если есть отложенное обновление и это не лист
        tm = (tl + tr) // 2  # Середина текущего отрезка
        
        # Обновляем левого ребенка
        trees[v*2] += lazy[v]
        lazy[v*2] += lazy[v]
        
        # Обновляем правого ребенка
        trees[v*2+1] += lazy[v]
        lazy[v*2+1] += lazy[v]
        
        # Сбрасываем текущее ленивое обновление
        lazy[v] = 0

def update(v, tl, tr, l, r, val):
    """Функция обновления: прибавляет val ко всем элементам на отрезке [l, r]"""
    if r < tl or tr < l:  # Если отрезки не пересекаются
        return
    
    if l <= tl and tr <= r:  # Если текущий отрезок полностью внутри [l, r]
        trees[v] += val      # Обновляем минимум
        lazy[v] += val       # Откладываем обновление для детей
        return
    
    # Если нужно спуститься в детей, сначала проталкиваем обновление
    push(v, tl, tr)
    tm = (tl + tr) // 2
    
    # Рекурсивно обновляем левого и правого ребенка
    update(v*2, tl, tm, l, r, val)
    update(v*2+1, tm+1, tr, l, r, val)
    
    # Пересчитываем минимум в текущей вершине
    trees[v] = min(trees[v*2], trees[v*2+1])

def query(v, tl, tr, l, r):
    """Функция запроса: возвращает минимум на отрезке [l, r]"""
    if r < tl or tr < l:  # Если отрезки не пересекаются
        return INF
    
    if l <= tl and tr <= r:  # Если текущий отрезок полностью внутри [l, r]
        return trees[v]
    
    # Если нужно спуститься в детей, сначала проталкиваем обновление
    push(v, tl, tr)
    tm = (tl + tr) // 2
    
    # Рекурсивно запрашиваем минимум из левого и правого поддерева
    return min(query(v*2, tl, tm, l, r),
               query(v*2+1, tm+1, tr, l, r))

# Обрабатываем m запросов
for _ in range(m):
    cmd = input[ptr]  # Тип операции (1 - обновление, 2 - запрос)
    
    if cmd == '1':
        # Операция прибавления: 1 l r v
        l = int(input[ptr+1])        # Левая граница
        r = int(input[ptr+2]) - 1    # Правая граница (преобразуем в 0-based индексы)
        v = int(input[ptr+3])        # Значение для прибавления
        ptr += 4                     # Сдвигаем указатель
        
        update(1, 0, size-1, l, r, v)
    
    elif cmd == '2':
        # Операция запроса минимума: 2 l r
        l = int(input[ptr+1])        # Левая граница
        r = int(input[ptr+2]) - 1    # Правая граница (преобразуем в 0-based индексы)
        ptr += 3                     # Сдвигаем указатель
        
        print(query(1, 0, size-1, l, r))