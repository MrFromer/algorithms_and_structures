# Чтение входных данных: n - размер массива, m - количество операций
n, m = [int(x) for x in input().split()]

# Инициализация структур данных для дерева отрезков:
# trees_sum - массив для хранения сумм на отрезках (4n - чтобы хватило места)
trees_sum = [0] * (4 * n) 

# lazy_sum - массив для отложенных операций прибавления (ленивые обновления)
lazy_sum = [0] * (4 * n) 

# lazy_add - массив для отложенных операций присваивания (-1 означает отсутствие операции)
lazy_add = [-1] * (4 * n) 

# Константа "бесконечность" (не используется в текущей реализации)
INF = 10**100

def push_sum(v, tl, tr):
    """
    Проталкивание отложенных операций прибавления вниз по дереву.
    v - текущая вершина, tl и tr - границы отрезка вершины.
    """
    if lazy_sum[v] != 0:  # Если есть невыполненное прибавление
        if tl != tr:  # Если это не лист
            tm = (tl + tr) // 2  # Середина отрезка
            
            # Обновляем левого ребенка
            trees_sum[v*2+1] += lazy_sum[v] * (tm - tl + 1)
            lazy_sum[v*2+1] += lazy_sum[v]
            
            # Обновляем правого ребенка
            trees_sum[v*2+2] += lazy_sum[v] * (tr - tm)
            lazy_sum[v*2+2] += lazy_sum[v]

        lazy_sum[v] = 0  # Сбрасываем флаг прибавления

def push_change(v, tl, tr):
    """
    Проталкивание отложенных операций присваивания вниз по дереву.
    v - текущая вершина, tl и tr - границы отрезка вершины.
    """
    if lazy_add[v] != -1:  # Если есть невыполненное присваивание
        if tl != tr:  # Если это не лист
            # Обновляем левого ребенка
            lazy_add[v*2+1] = lazy_add[v]
            trees_sum[v*2+1] = lazy_add[v] * ((tl + tr)//2 - tl + 1)
            lazy_sum[v*2+1] = 0  # Присваивание отменяет предыдущие прибавления
            
            # Обновляем правого ребенка
            lazy_add[v*2+2] = lazy_add[v]
            trees_sum[v*2+2] = lazy_add[v] * (tr - (tl + tr)//2)
            lazy_sum[v*2+2] = 0

        lazy_add[v] = -1  # Сбрасываем флаг присваивания

def change_elems(v, tl, tr, l, r, val):
    """
    Операция присваивания: установить значения на отрезке [l, r] в val.
    v - текущая вершина, tl и tr - границы текущего отрезка.
    """
    if tr < l or tl > r:  # Отрезки не пересекаются
        return 
    if l <= tl and tr <= r:  # Текущий отрезок полностью внутри [l, r]
        trees_sum[v] = val * (tr - tl + 1)  # Обновляем сумму
        lazy_add[v] = val  # Запоминаем операцию присваивания
        lazy_sum[v] = 0  # Сбрасываем прибавления (присваивание их отменяет)
        return

    # Проталкиваем отложенные операции перед обработкой детей
    push_change(v, tl, tr)
    push_sum(v, tl, tr) 

    tm = (tl + tr) // 2  # Середина текущего отрезка
    # Рекурсивно обрабатываем детей
    change_elems(v*2+1, tl, tm, l, r, val)
    change_elems(v*2+2, tm+1, tr, l, r, val)
    # Обновляем сумму в текущей вершине
    trees_sum[v] = trees_sum[2*v+1] + trees_sum[2*v+2]

def add_sum(v, tl, tr, l, r, val):
    """
    Операция прибавления: добавить val к элементам на отрезке [l, r].
    v - текущая вершина, tl и tr - границы текущего отрезка.
    """
    if tr < l or tl > r:  # Отрезки не пересекаются
        return 
    if l <= tl and tr <= r:  # Текущий отрезок полностью внутри [l, r]
        trees_sum[v] += val * (tr - tl + 1)  # Обновляем сумму
        lazy_sum[v] += val  # Запоминаем операцию прибавления
        return
    
    # Проталкиваем отложенные операции перед обработкой детей
    push_change(v, tl, tr)
    push_sum(v, tl, tr) 

    tm = (tl + tr) // 2  # Середина текущего отрезка
    # Рекурсивно обрабатываем детей
    add_sum(v*2+1, tl, tm, l, r, val)
    add_sum(v*2+2, tm+1, tr, l, r, val)
    # Обновляем сумму в текущей вершине
    trees_sum[v] = trees_sum[v*2+1] + trees_sum[v*2+2]

def find_sum(v, tl, tr, l, r):
    """
    Запрос суммы на отрезке [l, r].
    v - текущая вершина, tl и tr - границы текущего отрезка.
    """
    if tr < l or tl > r:  # Отрезки не пересекаются
        return 0
    if l <= tl and tr <= r:  # Текущий отрезок полностью внутри [l, r]
        return trees_sum[v]
    
    # Проталкиваем отложенные операции перед обработкой детей
    push_change(v, tl, tr)
    push_sum(v, tl, tr)

    tm = (tl + tr) // 2  # Середина текущего отрезка
    # Рекурсивно запрашиваем суммы у детей и складываем
    left = find_sum(v*2+1, tl, tm, l, r)
    right = find_sum(v*2+2, tm+1, tr, l, r)
    return left + right

# Основной цикл обработки операций
for _ in range(m):
    line = list(map(int, input().split()))
    type = line[0]  # Тип операции
    
    if type == 1:  # Операция присваивания
        l, r, v = line[1], line[2], line[3]  
        change_elems(0, 0, n - 1, l, r-1, v)  

    elif type == 2:  # Операция прибавления
        l, r, v = line[1], line[2], line[3]  
        add_sum(0, 0, n - 1, l, r-1, v)  

    elif type == 3:  # Запрос суммы
        l, r = line[1], line[2]
        print(find_sum(0, 0, n - 1, l, r-1))