import sys
input = sys.stdin.readline  # Используем быстрый ввод для больших данных

# Чтение входных данных
n, m = map(int, input().split())  # n - размер массива, m - количество операций
logs_moments = list(map(int, input().split()))  # Исходный массив чисел

# Инициализация дерева отрезков
trees = [0] * (4 * n)  # Выделяем память под дерево (4n достаточно для любого n)

def stroim_derevo(v, tl, tr):
    """
    Рекурсивная функция построения дерева отрезков
    v - текущая вершина дерева
    tl, tr - границы текущего отрезка
    """
    if tl == tr:  # Дошли до листа
        trees[v] = logs_moments[tl]  # Записываем значение из массива
    else:
        middle = (tl + tr) // 2  # Середина отрезка
        
        # Рекурсивно строим левое и правое поддерево
        stroim_derevo(v * 2 + 1, tl, middle)  # Левый ребенок [tl, middle]
        stroim_derevo(v * 2 + 2, middle + 1, tr)  # Правый ребенок [middle+1, tr]
        
        # Записываем максимум из двух детей
        trees[v] = max(trees[v * 2 + 1], trees[v * 2 + 2])


def change_derevo(v, tl, tr, pos, val):
    """
    Функция обновления значения в позиции pos
    v - текущая вершина
    tl, tr - границы отрезка
    pos - позиция для обновления
    val - новое значение
    """
    if tl == tr:  # Дошли до нужного листа
        trees[v] = val  # Обновляем значение
    else:
        middle = (tl + tr) // 2
        if pos <= middle:  # Ищем позицию в левом поддереве
            change_derevo(v * 2 + 1, tl, middle, pos, val)
        else:  # Ищем позицию в правом поддереве
            change_derevo(v * 2 + 2, middle + 1, tr, pos, val)
        
        # Пересчитываем максимум для текущей вершины
        trees[v] = max(trees[v * 2 + 1], trees[v * 2 + 2])


def find_one(v, tl, tr, x, l):
    """
    Поиск первого элемента > x правее позиции l
    v - текущая вершина
    tl, tr - границы текущего отрезка
    x - значение для сравнения
    l - левая граница поиска
    """
    # Если l выходит за границы массива
    if l >= n-1:  
        return -1
    
    # Если текущий отрезок полностью левее l
    if tr <= l + 1:
        return -1
    
    # Если максимум на отрезке меньше x - нет подходящих элементов
    if trees[v] < x:  
        return -1

    # Дошли до листа - проверяем условие
    if tl == tr:
        return tl if tl > l else -1  # Возвращаем индекс, если он > l

    middle = (tl + tr) // 2
    
    # Сначала проверяем левое поддерево, если оно пересекается с (l, ...)
    if middle > l:
        left = find_one(v * 2 + 1, tl, middle, x, l)
        if left != -1:  # Если нашли в левом поддереве - возвращаем
            return left
    
    # Если в левом не нашли, проверяем правое поддерево
    return find_one(v * 2 + 2, middle+1, tr, x, l)


# Основная программа

# Строим дерево отрезков для исходного массива
stroim_derevo(0, 0, n - 1)  # Начинаем с корня (0), всего отрезок [0, n-1]

# Обрабатываем m операций
for _ in range(m):
    line = list(map(int, input().split()))  # Читаем операцию
    type = line[0]  # Тип операции

    if type == 1:  # Операция обновления
        i, v = line[1], line[2]  # Позиция и новое значение
        change_derevo(0, 0, n - 1, i, v)  # Вызываем функцию обновления

    elif type == 2:  # Операция поиска
        x, l = line[1], line[2]  # Значение x и граница l
        print(find_one(0, 0, n - 1, x, l))  # Вызываем функцию поиска и выводим результат